# 创建型模式
## 1、单列模式
  对某个类只能存在一个对象实例，兵器该类只提供一个获取对象的是列方法。
  
  1) 打开程序就将实例现 new 出来。 直接加载
  2) 使用到该对象时，才去 new 出来。懒加载


---

### 2、工厂模式(依赖抽象)
将实例化对象的代码提取出来，放到一个类中，统一管理和维护。达到和主项目的依赖关系的解耦，而从提高项目
### 2.1 简单工厂模式
    把创建对象的行为封装到一个类中，这样有新的对象时，只需要修改该类就可以了。其它有创建对象的代码就不需要修改了。(只提供一个入口，创建对象，统一管理)，如果分散创建就太乱了。

### 2.2 工厂方法模式
    定义一个创建对象的抽象方法，由子类决定要创建的产品。(将创建对象延迟到子类创建中)
  
---

### 3、原型模式
原型模式用原型实例制定创建对象种类，并通过拷贝这些原型创建新的对象。并且后期对对象添加了新的属性后，客户端
也不需修改。
1) 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程。同事也能提高效率
2) 不用重新初始化对象的状态，而是直接动态的获取对象的运算时状态。
3) 在实现深度克隆时比较复杂。

### 4、建造者模式
1) 将产品和产品建造的过程解耦。
2) 一步一步创建一个复杂的对象，它允许用户只通过制定复杂的对象和内容就可以构架它们。
3) 将产品本身与产品创建过程抽离。


# 结构性模式

## 1、适配器模式
将某个类的接口转为客户端期望另一个接口的表示，主要时兼容性，让原本接口不匹配不能一起工作的两个类可与协同工作。
在实际开发中，不一定非要适配类，也有可能是适配一个函数或方法的参数、返回值。

1) 类适配器: 新建一个对象继承需要被适配的对象。
2) 对象适配器:  不再继承被适配的对象，只需要聚合被适配的对象。(尽量使用关联的关系，而不是继承的关系)
3) 接口适配器: 将一系列方法抽象成一个对象的默认实现，客户端使用时，只需要重写自己需要的方法。简化参数传递？？？

### 2、桥接模式

1) 将实现与抽象放在两个不同层次中；使两个层次可以独立改变。
2) 通过使用封装、聚合、继承等行为让不同的类承担不同的职责。


## 3、装饰器模式
1) 装饰者模式，动态的将新功能动态的附加到对象上，在对象功能扩展的方面；它比继承更有弹性。

## 4、组合模式。
1) 他创建了对象的树形结构，对对象组合成树状结构以表示 整体；部分。的层次关系。 
2) 具有较强的扩展性，当我们要更改组合对象时，我们只需要调整内部层次关系客户端不用做出任何改动。

## 5、外观模式
1) 外观模式位子系统中的一组接口提供了一个一致的界面，次模式定义了一个高层接口。这个接口使得着一个子系统更加容易使用。

## 6、享元模式
1) 运用共享技术有效的支持大量细粒度的对象。
2) 常见于系统低层的开发，解决系统性能问题；向数据库链接。
3) 能够解决重复对象的内存浪费的问题。

  内部状态: 对象共享出来的信息，存在在对象的内部；且不随环境变化而变化。
  外部状态: 随环境变化而变化。不可共享。

  比如棋子: 棋子的颜色时内部状态。棋子的位置时外部状态。

## 7、代理模式
  1) 为一个对象提供一个对象，以控制这个对象的访问。即通过代理对象访问目标对象。可以在目标对象实现的基础上，增强额外的
  功能扩展。
  2) 静态代理: 通过接口或者继承的方式来实现。
  3) 动态代理: 通过语言的特性，比如反反射机制来实现动态代理。 如 go 的反射，js 的 Proxy 类。
  
  装饰器模式是增强该对象的功能，而代理模式只是控制该对象的访问方式，或者做一些不相关的事情。比如记录日志。
