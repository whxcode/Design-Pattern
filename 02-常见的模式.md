# 创建型模式
## 1、单列模式
  对某个类只能存在一个对象实例，兵器该类只提供一个获取对象的是列方法。
  
  1) 打开程序就将实例现 new 出来。 直接加载
  2) 使用到该对象时，才去 new 出来。懒加载


---

### 2、工厂模式(依赖抽象)
将实例化对象的代码提取出来，放到一个类中，统一管理和维护。达到和主项目的依赖关系的解耦，而从提高项目
### 2.1 简单工厂模式
    把创建对象的行为封装到一个类中，这样有新的对象时，只需要修改该类就可以了。其它有创建对象的代码就不需要修改了。(只提供一个入口，创建对象，统一管理)，如果分散创建就太乱了。

### 2.2 工厂方法模式
    定义一个创建对象的抽象方法，由子类决定要创建的产品。(将创建对象延迟到子类创建中)
  
---

### 3、原型模式
原型模式用原型实例制定创建对象种类，并通过拷贝这些原型创建新的对象。并且后期对对象添加了新的属性后，客户端
也不需修改。
1) 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程。同事也能提高效率
2) 不用重新初始化对象的状态，而是直接动态的获取对象的运算时状态。
3) 在实现深度克隆时比较复杂。

### 4、建造者模式
1) 将产品和产品建造的过程解耦。
2) 一步一步创建一个复杂的对象，它允许用户只通过制定复杂的对象和内容就可以构架它们。
3) 将产品本身与产品创建过程抽离。


# 结构性模式

## 1、适配器模式
将某个类的接口转为客户端期望另一个接口的表示，主要时兼容性，让原本接口不匹配不能一起工作的两个类可与协同工作。
在实际开发中，不一定非要适配类，也有可能是适配一个函数或方法的参数、返回值。

1) 类适配器: 新建一个对象继承需要被适配的对象。
2) 对象适配器:  不再继承被适配的对象，只需要聚合被适配的对象。(尽量使用关联的关系，而不是继承的关系)
3) 接口适配器: 将一系列方法抽象成一个对象的默认实现，客户端使用时，只需要重写自己需要的方法。简化参数传递？？？

### 2、桥接模式

1) 将实现与抽象放在两个不同层次中；使两个层次可以独立改变。
2) 通过使用封装、聚合、继承等行为让不同的类承担不同的职责。


## 3、装饰器模式
1) 装饰者模式，动态的将新功能动态的附加到对象上，在对象功能扩展的方面；它比继承更有弹性。

## 4、组合模式。
      他创建了对象的树形结构，对对象组合成树状结构以表示 整体；部分。的层次关系。 
