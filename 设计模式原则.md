## 设计模式原则

### 1) 单一职责模式。 
  1) 降低类的复杂度，一个类(或一个方法)只负责一项职责.
  2) 提高类的可读性，可维护性
  3) 降低变更引起的风险
  4) 通常情况下，我们应当准守单一职责，只有逻辑足够简单才可以在代码中违背单一职责。

  ```
  通常一个类只负责自己业务相关的功能；一个方法只处理自身相关的功能，和业务不相关的 if 分支，尽量
  将 if 抽离出来。
  ```

### 2) 接口隔离原则
 客户端不应该依赖它不需要的接口，即一个类对另外一个类的依赖，应该建立在最小的接口上。
 即: 不要将多与的参数传递给相关方法函数。
 interface App {
 char name;
 int age;
 }

 void worker(App app) {
 cout << app.name << endl;
 }

 App app = {name:'w',age:1}

 worker(app)

 函数 worker 只用到了 app 的 name 字段，但参数声明却是整个 app,这样子在函数中，就可以访问了，age.
 应该:
  interface IParams {char name}
  void worker(IParams params) {}
  这样子拆分了，在正常情况下就不能访问 age 字段了。


### 3) 依赖倒转原则
1) 高层模块不应该依赖底层模块，二者都应该依赖抽象。
2) 抽象不应该依赖细节，细节应该依赖抽象。
3) 依赖倒转的中心思想，是面向接口编成。
4) 使用接口或抽象的目的是制定好规范，而不涉及任何具体的操作，把展示细节的任务交给他们的实现类器完成。

```
常见的依赖方式.
  1、基于抽象层来传递.(类似于调用函数，传递对应的参数),只有当前方法能使用。
  2、依赖构造方法传递.(在类构造时，就需要把依赖的接口实现传递进去,该类由一个属性来保存)构造后，这个类的所有方法都可以访问。
  3、在类构造之后，通过 setter 传递进去。需要设置后，类的所用方法才可以访问。

  第一种依赖关系小。第二种依赖关系很强，没有传递接口，该类无法构建。第三种依赖也很强，但也能构建类。按是无法使用设计的方法。
```
